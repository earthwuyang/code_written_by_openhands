import logging

from selection.index import Index
from selection.selection_algorithm import DEFAULT_PARAMETER_VALUES, SelectionAlgorithm
from selection.utils import b_to_mb, mb_to_b
from selection.workload import Workload

# budget_MB: The algorithm can utilize the specified storage budget in MB.
# max_index_width: The number of columns an index can contain at maximum.
# min_cost_improvement: The value of the relative improvement that must be realized by a
#                       new configuration to be selected.
# The algorithm stops if either the budget is exceeded or no further beneficial
# configurations can be found.
DEFAULT_PARAMETERS = {
    "budget_MB": DEFAULT_PARAMETER_VALUES["budget_MB"],
    "max_index_width": DEFAULT_PARAMETER_VALUES["max_index_width"],
    "min_cost_improvement": 0.99999,  # Ultra aggressive: allow up to 0.001% degradation
}


# This algorithm is a reimplementation of the Extend heuristic published by Schlosser,
# Kossmann, and Boissier in 2019.
# Details can be found in the original paper:
# Rainer Schlosser, Jan Kossmann, Martin Boissier: Efficient Scalable
# Multi-attribute Index Selection Using Recursive Strategies. ICDE 2019: 1238-1249
class ExtendAlgorithm(SelectionAlgorithm):
    def __init__(self, database_connector, parameters=None):
        if parameters is None:
            parameters = {}
        SelectionAlgorithm.__init__(
            self, database_connector, parameters, DEFAULT_PARAMETERS
        )
        self.budget = mb_to_b(self.parameters["budget_MB"])
        self.max_index_width = self.parameters["max_index_width"]
        self.workload = None
        self.min_cost_improvement = self.parameters["min_cost_improvement"]

    def _calculate_best_indexes(self, workload):
        logging.info("Calculating best indexes Extend")
        self.workload = workload
        single_attribute_index_candidates = self.workload.potential_indexes()
        extension_attribute_candidates = single_attribute_index_candidates.copy()

        # Current index combination
        index_combination = []
        index_combination_size = 0
        # Best index combination during evaluation step
        best = {"combination": [], "benefit_to_size_ratio": 0, "cost": None}

        current_cost = self.cost_evaluation.calculate_cost(
            self.workload, index_combination, store_size=True
        )
        self.initial_cost = current_cost
        # Breaking when no cost improvement
        while True:
            single_attribute_index_candidates = self._get_candidates_within_budget(
                index_combination_size, single_attribute_index_candidates
            )
            for candidate in single_attribute_index_candidates:
                # Only single column index generation
                if candidate not in index_combination:
                    self._evaluate_combination(
                        index_combination + [candidate], best, current_cost
                    )

            for attribute in extension_attribute_candidates:
                # Multi column indexes are generated by attaching columns
                # to existing indexes
                self._attach_to_indexes(index_combination, attribute, best, current_cost)
            if best["benefit_to_size_ratio"] <= 0:
                break

            index_combination = best["combination"]
            index_combination_size = sum(
                index.estimated_size for index in index_combination
            )
            logging.debug(
                "Add index. Current cost savings: "
                f"{(1 - best['cost'] / current_cost) * 100:.3f}, "
                f"initial {(1 - best['cost'] / self.initial_cost) * 100:.3f}. "
                f"Current storage: {index_combination_size:.2f}"
            )

            best["benefit_to_size_ratio"] = 0
            current_cost = best["cost"]

        return index_combination

    def _attach_to_indexes(self, index_combination, attribute, best, current_cost):
        assert (
            attribute.is_single_column() is True
        ), "Attach to indexes called with multi column index"

        for position, index in enumerate(index_combination):
            if len(index.columns) >= self.max_index_width:
                continue
            if index.appendable_by(attribute):
                new_index = Index(index.columns + attribute.columns)
                if new_index in index_combination:
                    continue
                new_combination = index_combination.copy()
                # We don't replace, but del and append to keep track of the append order
                del new_combination[position]
                new_combination.append(new_index)
                self._evaluate_combination(
                    new_combination,
                    best,
                    current_cost,
                    index_combination[position].estimated_size,
                )

    def _get_candidates_within_budget(self, index_combination_size, candidates):
        new_candidates = []
        for candidate in candidates:
            if (candidate.estimated_size is None) or (
                candidate.estimated_size + index_combination_size <= self.budget
            ):
                new_candidates.append(candidate)
        return new_candidates

    def _evaluate_combination(
        self, index_combination, best, current_cost, old_index_size=0
    ):
        # Use a sample of queries for faster evaluation
        sample_size = min(5, len(self.workload.queries))
        sample_workload = Workload(self.workload.queries[-sample_size:])
        
        cost = self.cost_evaluation.calculate_cost(
            sample_workload, index_combination, store_size=True
        )
        
        # # Log evaluation details
        # logging.info(f"\nEvaluating index combination:")
        # logging.info(f"  Current indexes: {[str(i) for i in index_combination[:-1]]}")
        # logging.info(f"  New index: {index_combination[-1]}")
        # logging.info(f"  Current cost: {current_cost:.2f}")
        # logging.info(f"  New cost: {cost:.2f}")
        
        # Calculate relative improvement
        relative_improvement = (current_cost - cost) / current_cost if current_cost > 0 else 0
        # logging.info(f"  Relative improvement: {relative_improvement:.2%}")
        
        # Calculate total size first
        total_size = sum(index.estimated_size for index in index_combination)

        # More aggressive acceptance criteria
        min_improvement = self.min_cost_improvement
        if len(index_combination) <= 3:  # Be more lenient with initial indexes
            min_improvement = 1.01  # Allow up to 1% degradation for first few indexes
        elif total_size < self.budget * 0.5:  # Be more lenient when we have budget
            min_improvement = 1.005  # Allow up to 0.5% degradation if under 50% budget
            
        if (cost * min_improvement) >= current_cost:
            logging.info(f"  Rejected: Insufficient improvement (needs {(min_improvement-1)*100:.3f}%)")
            return
            
        benefit = current_cost - cost
        new_index = index_combination[-1]
        new_index_size_difference = new_index.estimated_size - old_index_size
        if new_index_size_difference == 0:
            # Skip if there's no size difference (can happen with small indexes)
            logging.info("  Rejected: No size difference")
            return

        ratio = benefit / new_index_size_difference

        logging.info(f"  Benefit: {benefit:.2f}")
        logging.info(f"  Size difference: {b_to_mb(new_index_size_difference):.2f}MB")
        logging.info(f"  Benefit/size ratio: {ratio:.2f}")
        logging.info(f"  Total size: {b_to_mb(total_size):.2f}MB")
        logging.info(f"  Budget: {b_to_mb(self.budget):.2f}MB")

        # More aggressive selection criteria
        accept_index = False
        if total_size <= self.budget:
            if len(index_combination) <= 3:
                # Always accept first few indexes if they show any improvement
                accept_index = relative_improvement > 0
            elif total_size < self.budget * 0.5:
                # Be more lenient when we have plenty of budget
                accept_index = ratio > best["benefit_to_size_ratio"] * 0.8
            else:
                # Normal case: must beat current best ratio
                accept_index = ratio > best["benefit_to_size_ratio"]

        if accept_index:
            logging.info(
                f"Found better combination: cost={cost:.2f}, "
                f"size={b_to_mb(total_size):.2f}MB, ratio={ratio:.2f}, "
                f"improvement={relative_improvement:.2%}"
            )
            best["combination"] = index_combination
            best["benefit_to_size_ratio"] = ratio
            best["cost"] = cost
        else:
            if total_size > self.budget:
                logging.info("  Rejected: Budget exceeded")
            elif len(index_combination) <= 3:
                logging.info("  Rejected: No improvement for initial index")
            elif total_size < self.budget * 0.5:
                logging.info(f"  Rejected: Ratio {ratio:.2f} not better than {best['benefit_to_size_ratio']*0.8:.2f} (80% of best)")
            else:
                logging.info(f"  Rejected: Ratio {ratio:.2f} not better than {best['benefit_to_size_ratio']:.2f}")
